#include <iostream>
bool xod_of_player;
char pole_player [10][10]; // 0 ~ неоткрытая клетка без корабля, 1 ~ неоткрытая клетка с кораблём, 2 ~ открытая клетка без корабля, 3 ~ открытая клетка с кораблём, 4 ~ клетка, на которую нельзя ставить корабль (= 0..9)
char pole_ai [10][10];  // = (0..9)
struct ship {
    int x;
    int y;
};
ship ship1[4]; // [номер корабля] (= 0..9)
ship ship2[2][3]; // [номер клетки][номер корабля] (= 0..9)
ship ship3[3][2]; // [номер клетки][номер корабля] (= 0..9)
ship ship4[4]; // [номер клетки]
ship ship1_ai[4]; // [номер клетки] компьютер
ship ship2_ai[2][3]; //[номер клетки][номер корабля] компьютер
ship ship3_ai[3][2]; //[номер клетки][номер корабля] компьютер
ship ship4_ai[4]; //[номер корабля] компьютер
void ship_ai() { //задание кораблей компьютера
    bool possible; // проверяет можно ли поставить корабли; сначала нельзя (false), чтобы можно было войти в цикл
    int i, j;
    int x, y;
    x = rand() % 10; // задание 4-ёх палубника
    y = rand() % 10;
    if (rand() % 2 == 1) { // корабль стоит вертикально
        if (y > 6)
            y = rand() % 7;
        for (i = 0; i < 4; i++) {
            ship4_ai[i].x = x;  // задание точек корабля в массиве корабля на оси х
            ship4_ai[i].y = y + i;  // задание точек корабля в массиве корабля на оси у
            pole_ai[ship4_ai[i].x][ship4_ai[i].y] = 1; // задание точек корабля на поле
            if (ship4_ai[i].x - 1 > -1)
                pole_ai[ship4_ai[i].x - 1][ship4_ai[i].y] = 4; // задание на поле точек, находящихся слева от корабля, на которые нельзя ставить корабли
            if (ship4_ai[i].x + 1 < 10)
                pole_ai[ship4_ai[i].x + 1][ship4_ai[i].y] = 4; // задание на поле точек, находящихся справа от корабля, на которые нельзя ставить корабли
        }
        for (j = 0; j < 3; j++) {
            if ((x - 1 + j > -1) && (y - 1 > -1) && (x - 1 + j < 10))
                pole_ai[x - 1 + j][y - 1] = 4;  // задание на поле точек, находящихся выше корабля, на которые нельзя ставить корабли
            if ((x - 1 + j > -1) && (y + 4 < 10) && (x - 1 + j < 10))
                pole_ai[x - 1 + j][y + 4] = 4;  // задание на поле точек, находящихся ниже корабля, на которые нельзя ставить корабли
        }
    }
    else {
        if (x > 6)
            x = rand() % 7; // корабль стоит горизонтально
        for (i = 0; i < 4; i++) {
            ship4_ai[i].x = x + i;  // задание точек корабля в массиве корабля на оси х
            ship4_ai[i].y = y;  // задание точек корабля в массиве корабля на оси у
            pole_ai[ship4_ai[i].x][ship4_ai[i].y] = 1; // задание точек корабля на поле
            if (ship4_ai[i].y - 1 > -1)
                pole_ai[ship4_ai[i].x][ship4_ai[i].y - 1] = 4; // задание на поле точек, находящихся выше корабля, на которые нельзя ставить корабли
            if (ship4_ai[i].y + 1 < 10)
                pole_ai[ship4_ai[i].x][ship4_ai[i].y + 1] = 4; // задание на поле точек, находящихся ниже корабля, на которые нельзя ставить корабли
        }
        for (j = 0; j < 3; j++) {
            if ((y - 1 + j > -1) && (x - 1 > -1) && (y - 1 + j < 10))
                pole_ai[x - 1][y - 1 + j] = 4;  // задание на поле точек, находящихся слева от корабля, на которые нельзя ставить корабли
            if ((y - 1 + j > -1) && (x + 4 < 10) && (y - 1 + j < 10))
                pole_ai[x + 4][y - 1 + j] = 4;  // задание на поле точек, находящихся справа от корабля, на которые нельзя ставить корабли
        }
    } // конец задания четырёхпалубника
    for (j = 0; j < 2; j++) { // задание трёхпалубников
        if (rand() % 2 == 1) { // корабль стоит вертикально
            possible = false;
            while (!possible) {
                x = rand() % 10;
                y = rand() % 8;
                possible = true;
                for (i = 0; i < 3; i++) {
                    if (pole_ai[x][y + i] != 0) {
                        possible = false;
                    }
                }
                if (possible) {
                    for (i = 0; i < 3; i++) {
                        ship3_ai[i][j].x = x;  // задание точек корабля в массиве корабля на оси х
                        ship3_ai[i][j].y = y + i;  // задание точек корабля в массиве корабля на оси у
                        pole_ai[ship3_ai[i][j].x][ship3_ai[i][j].y] = 1; // задание точек корабля на поле
                        if (ship3_ai[i][j].x - 1 > -1)
                            pole_ai[ship3_ai[i][j].x - 1][ship3_ai[i][j].y] = 4; // задание на поле точек, находящихся слева от корабля, на которые нельзя ставить корабли
                        if (ship3_ai[i][j].x + 1 < 10)
                            pole_ai[ship3_ai[i][j].x + 1][ship3_ai[i][j].y] = 4; // задание на поле точек, находящихся справа от корабля, на которые нельзя ставить корабли
                    }
                    for (i = 0; i < 3; i++) {
                        if ((x - 1 + i > -1) && (y - 1 > -1) && (x - 1 + i < 10))
                            pole_ai[x - 1 + i][y - 1] = 4;  // задание на поле точек, находящихся выше корабля, на которые нельзя ставить корабли
                        if ((x - 1 + i > -1) && (y + 3 < 10) && (x - 1 + i < 10))
                            pole_ai[x - 1 + i][y + 3] = 4;  // задание на поле точек, находящихся ниже корабля, на которые нельзя ставить корабли
                    }
                }
            }
        }


        else { // корабль стоит горизонтально
            possible = false;
            while (!possible) {
                y = rand() % 10;
                x = rand() % 8;
                possible = true;
                for (i = 0; i < 3; i++) {
                    if (pole_ai[x + i][y] != 0) {
                        possible = false;
                    }
                }
                if (possible) {
                    for (i = 0; i < 3; i++) {
                        ship3_ai[i][j].x = x + i;  // задание точек корабля в массиве корабля на оси х
                        ship3_ai[i][j].y = y;  // задание точек корабля в массиве корабля на оси у
                        pole_ai[ship3_ai[i][j].x][ship3_ai[i][j].y] = 1; // задание точек корабля на поле
                        if (ship3_ai[i][j].y - 1 > -1)
                            pole_ai[ship3_ai[i][j].x][ship3_ai[i][j].y - 1] = 4; // задание на поле точек, находящихся выше корабля, на которые нельзя ставить корабли
                        if (ship3_ai[i][j].y + 1 < 10)
                            pole_ai[ship3_ai[i][j].x][ship3_ai[i][j].y + 1] = 4; // задание на поле точек, находящихся ниже корабля, на которые нельзя ставить корабли
                    }
                    for (i = 0; i < 3; i++) {
                        if ((y - 1 + i > -1) && (x - 1 > -1) && (y - 1 + i < 10))
                            pole_ai[x - 1][y - 1 + i] = 4;  // задание на поле точек, находящихся левее корабля, на которые нельзя ставить корабли
                        if ((y - 1 + i > -1) && (x + 3 < 10) && (y - 1 + i < 10))
                            pole_ai[x + 3][y - 1 + i] = 4;  // задание на поле точек, находящихся правее корабля, на которые нельзя ставить корабли
                    }
                }
            }



        }

    } // конец задания трёхпалубников
    for (j = 0; j < 3; j++){ // задание двухпалубников

        if (rand() % 2 == 1) { // корабль стоит вертикально
            possible = false;
            while (!possible) {
                x = rand() % 10;
                y = rand() % 9;
                possible = true;
                for (i = 0; i < 2; i++) {
                    if (pole_ai[x][y + i] != 0) {
                        possible = false;
                    }
                }
                if (possible) {
                    for (i = 0; i < 2; i++) {
                        ship2_ai[i][j].x = x;  // задание точек корабля в массиве корабля на оси х
                        ship2_ai[i][j].y = y + i;  // задание точек корабля в массиве корабля на оси у
                        pole_ai[ship2_ai[i][j].x][ship2_ai[i][j].y] = 1; // задание точек корабля на поле
                        if (ship2_ai[i][j].x - 1 > -1)
                            pole_ai[ship2_ai[i][j].x - 1][ship2_ai[i][j].y] = 4; // задание на поле точек, находящихся слева от корабля, на которые нельзя ставить корабли
                        if (ship2_ai[i][j].x + 1 < 10)
                            pole_ai[ship2_ai[i][j].x + 1][ship2_ai[i][j].y] = 4; // задание на поле точек, находящихся справа от корабля, на которые нельзя ставить корабли
                    }
                    for (i = 0; i < 3; i++) {
                        if ((x - 1 + i > -1) && (y - 1 > -1) && (x - 1 + i < 10))
                            pole_ai[x - 1 + i][y - 1] = 4;  // задание на поле точек, находящихся выше корабля, на которые нельзя ставить корабли
                        if ((x - 1 + i > -1) && (y + 2 < 10) && (x - 1 + i < 10))
                            pole_ai[x - 1 + i][y + 2] = 4;  // задание на поле точек, находящихся ниже корабля, на которые нельзя ставить корабли
                    }
                }
            }
        }


        else { // корабль стоит горизонтально
            possible = false;
            while (!possible) {
                y = rand() % 10;
                x = rand() % 9;
                possible = true;
                for (i = 0; i < 2; i++) {
                    if (pole_ai[x + i][y] != 0) {
                        possible = false;
                    }
                }
                if (possible) {
                    for (i = 0; i < 2; i++) {
                        ship2_ai[i][j].x = x + i;  // задание точек корабля в массиве корабля на оси х
                        ship2_ai[i][j].y = y;  // задание точек корабля в массиве корабля на оси у
                        pole_ai[ship2_ai[i][j].x][ship2_ai[i][j].y] = 1; // задание точек корабля на поле
                        if (ship2_ai[i][j].y - 1 > -1)
                            pole_ai[ship2_ai[i][j].x][ship2_ai[i][j].y - 1] = 4; // задание на поле точек, находящихся выше корабля, на которые нельзя ставить корабли
                        if (ship2_ai[i][j].y + 1 < 10)
                            pole_ai[ship2_ai[i][j].x][ship2_ai[i][j].y + 1] = 4; // задание на поле точек, находящихся ниже корабля, на которые нельзя ставить корабли
                    }
                    for (i = 0; i < 3; i++) {
                        if ((y - 1 + i > -1) && (x - 1 > -1) && (y - 1 + i < 10))
                            pole_ai[x - 1][y - 1 + i] = 4;  // задание на поле точек, находящихся левее корабля, на которые нельзя ставить корабли
                        if ((y - 1 + i > -1) && (x + 2 < 10) && (y - 1 + i < 10))
                            pole_ai[x + 2][y - 1 + i] = 4;  // задание на поле точек, находящихся правее корабля, на которые нельзя ставить корабли
                    }
                }
            }



        } // конец задания двухпалубников

        for (j = 0; j < 4;j++) { //
            possible = false;
            while (!possible) {
                x = rand() % 10;
                y = rand() % 10;
                possible = true;
                if (pole_ai[x][y] != 0) {
                    possible = false;
                }
                if (possible) {
                    ship1_ai[j].x = x;  // задание точек корабля в массиве корабля на оси х
                    ship1_ai[j].y = y;  // задание точек корабля в массиве корабля на оси у
                    pole_ai[ship1_ai[j].x][ship1_ai[j].y] = 1; // задание точек корабля на поле
                    if (ship1_ai[j].x - 1 > -1)
                        pole_ai[ship1_ai[j].x - 1][ship1_ai[j].y] = 4; // задание на поле точек, находящихся слева от корабля, на которые нельзя ставить корабли
                    if (ship1_ai[j].x + 1 < 10)
                        pole_ai[ship1_ai[j].x + 1][ship1_ai[j].y] = 4; // задание на поле точек, находящихся справа от корабля, на которые нельзя ставить корабли

                    for (i = 0; i < 3; i++) {
                        if ((x - 1 + i > -1) && (y - 1 > -1) && (x - 1 + i < 10))
                            pole_ai[x - 1 + i][y - 1] = 4;  // задание на поле точек, находящихся выше корабля, на которые нельзя ставить корабли
                        if ((x - 1 + i > -1) && (y + 1 < 10) && (x - 1 + i < 10))
                            pole_ai[x - 1 + i][y + 1] = 4;  // задание на поле точек, находящихся ниже корабля, на которые нельзя ставить корабли
                    }
                }
            }
        }


    }





}
void point (){ //задание кораблей игрока
    int i;
    int j;
    if (ship4[0].x>ship4[3].x) {  //задание и упорядочивание точек 4-ёх плубника
        ship4[0].x=ship4[0].x+ship4[3].x;
        ship4[3].x=ship4[0].x-ship4[3].x;
        ship4[0].x=ship4[0].x-ship4[3].x; //x0=min(x0,x3) x3=max(x0,x3)
        ship4[1].x= ship4[0].x+1; //x1=x0+1
        ship4[2].x= ship4[0].x+2; //x2=x0+2
        ship4[1].y = ship4[0].y; //y1=y0
        ship4[2].y = ship4[0].y; //y2=y0
    }
    else {
        if (ship4[0].y > ship4[3].y) {
            ship4[0].y = ship4[0].y + ship4[3].y;
            ship4[3].y = ship4[0].y - ship4[3].y;
            ship4[0].y = ship4[0].y - ship4[3].y; //y0=min(y0,y3) y3=max(y0,y3)
            ship4[1].y=ship4[0].y+1; //y1=y0+1
            ship4[2].y=ship4[0].y+2; //y2=y0+2
            ship4[1].x=ship4[0].x; //x1=x0
            ship4[2].x=ship4[0].x; //x2=x0

        }
    }
    for (j=0;j<4;j++)
        pole_player[ship4[j].x][ship4[j].y]=1; //задание и упорядочивание точек 4-ёх палубника на поле игрока
    for (i=0;i<2;i++) {
        if (ship3[0][i].x > ship3[2][i].x) { //задание точек 3-ёх плубника
            ship3[0][i].x = ship3[0][i].x + ship3[2][i].x;
            ship3[2][i].x = ship3[0][i].x - ship3[2][i].x;
            ship3[0][i].x = ship3[0][i].x - ship3[2][i].x; //x0=min(x0,x2) x3=max(x0,x2)
            ship3[1][i].x = ship3[0][i].x+1; //x1=x0+1
            ship3[1][i].y = ship3[0][i].y; //y1=y0
        }
        else
            if (ship3[0][i].y > ship3[2][i].y) {
            ship3[0][i].y = ship3[0][i].y + ship3[2][i].y;
            ship3[2][i].y = ship3[0][i].y - ship3[2][i].y;
            ship3[0][i].y = ship3[0][i].y - ship3[2][i].y; //y0=min(y0,y3) y3=max(y0,y3)
            ship3[1][i].y = ship3[0][i].y+1; //y1=y0+1
            ship3[1][i].x = ship3[0][i].x; //x1=x0

        }
        for (j=0;j<3;j++)
            pole_player[ship3[j][i].x][ship3[j][i].y]=1; //задание и упорядочивание точек 3-ёх палубника на поле игрока
    }
    for (i=0;i<3;i++) {
        if (ship2[0][i].x > ship2[1][i].x) {  //упорядочивание точек 2-yх палубника
            ship2[0][i].x = ship2[0][i].x + ship2[1][i].x;
            ship2[1][i].x = ship2[0][i].x - ship2[1][i].x;
            ship2[0][i].x = ship2[0][i].x - ship2[1][i].x; //x0=min(x0,x1) x3=max(x0,x1)
        }
        else if (ship2[0][i].y > ship2[1][i].y) {
            ship2[0][i].y = ship2[0][i].y + ship2[1][i].y;
            ship2[1][i].y = ship2[0][i].y - ship2[1][i].y;
            ship2[0][i].y = ship2[0][i].y - ship2[1][i].y; //y0=min(y0,y1) y3=max(y0,y1)
        }
        for(j=0;j<2;j++)
            pole_player[ship2[j][i].x][ship2[j][i].y]=1;
    }
    for (i=0;i<4;i++)
        pole_player[ship1[i].x][ship1[i].y]=1;

}
void player() { // считывает или определяет выстрел
    char x;
    int y;
    if (xod_of_player==1){
        scanf("%c%i",&x,&y); //A=65 a=97
    }
    else {
        srand ( time(NULL) );
        x=rand()%10;
        srand ( time(NULL) );
        y=rand()%10;
    }

}
int main() {
    int i,j;
    for (i=0;i<10;i++) // обнуление клеток полей
        for (j=0;j<10;j++) {
            pole_player[i][j] = 0;
            pole_ai[i][j] = 0;
        }
    //printf();
    scanf("%i%i%i%i",&ship4[0].x,&ship4[0].y,&ship4[3].x,&ship4[3].y); // координаты начала и конца
    //printf();
    scanf("%i%i%i%i%i%i%i%i",&ship3[0][0].x,&ship3[0][0].y,&ship3[2][0].x,&ship3[2][0].y,&ship3[0][1].x,&ship3[0][1].y,&ship3[2][1].x,&ship3[2][1].y);  // координаты начала и конца
    //printf();
    scanf("%i%i%i%i%i%i%i%i%i%i%i%i",&ship2[0][0].x,&ship2[0][0].y,&ship2[1][0].x,&ship2[1][0].y,&ship2[0][1].x,&ship2[0][1].y,&ship2[1][1].x,&ship2[1][1].y,&ship2[0][2].x,&ship2[0][2].y,&ship2[1][2].x,&ship2[1][2].y);  // координаты начала и конца
    //printf();
    scanf("%i%i%i%i%i%i%i%i",&ship1[0].x,&ship1[0].y,&ship1[1].x,&ship1[1].y,&ship1[2].x,&ship1[2].y,&ship1[3].x,&ship1[3].y);  // координаты начала и конца
    point();
    srand ( time(NULL) );
    ship_ai();
    if (rand()%2==1) xod_of_player = 1; // выбирается, кто ходит первым
    else xod_of_player = 0;
    player();
    return 0;
}//srand ( time(NULL) ); rand()%10