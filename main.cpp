#include <iostream>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <w32api/minwindef.h>
#include <w32api/ntdef.h>
bool xod_of_player;
char pole_player [10][10]; // 0 ~ неоткрытая клетка без корабля, 1 ~ неоткрытая клетка с кораблём, 2 ~ открытая клетка без корабля, 3 ~ открытая клетка с кораблём, 4 ~ клетка, на которую нельзя ставить корабль
char pole_ai [10][10];
int ship1[2][4]; // [x~0,y~1][number of ship] (= 0..9)
int ship2[2][2][3]; // 2-ух палубники [x~0,y~1][номер клетки][номер корабля] (= 0..9)
int ship3[2][3][2]; // 3-ёх палубники [x~0,y~1][номер клетки][номер корабля](= 0..9)
int ship4[2][4]; // 4-ёх палубники [x~0,y~1][номер клетки](= 0..9)
int ship1_ai[2][4]; // [x~0,y~1][number of ship] компьютер
int ship2_ai[2][2][3]; // 2-ух палубники [x~0,y~1][номер клетки][номер корабля] компьютер
int ship3_ai[2][3][2]; // 3-ёх палубники [x~0,y~1][номер клетки][номер корабля] компьютер
int ship4_ai[2][4]; // 4-ёх палубники [x~0,y~1][номер клетки] компьютер
void ship_ai(){ //задание кораблей компьютера
    int i,j;
    int x,y;
    x=rand()%10; // задание 4-ёх палубника
    y=rand()%10;
    if (rand()%2==1) { // корабль стоит вертикально
        if (y > 6)
            y = rand() % 7;
        for (i=0;i<4;i++) {
            ship4_ai[0][i]=x;  // задание точек корабля в массиве корабля на оси х
            ship4_ai[1][i]=y+i;  // задание точек корабля в массиве корабля на оси у
            pole_ai[ship4_ai[0][i]][ship4_ai[1][i]]=1; // задание точек корабля на поле
            if (ship4_ai[0][i]-1 > -1) pole_ai[ship4_ai[0][i]-1][ship4_ai[1][i]]=4; // задание на поле точек, находящихся слева от корабля, на которые нельзя ставить корабли
            if (ship4_ai[0][i]+1 < 10) pole_ai[ship4_ai[0][i]+1][ship4_ai[1][i]]=4; // задание на поле точек, находящихся справа от корабля, на которые нельзя ставить корабли
        }
        for (j=0;j<3;j++) {
            if ((x-1+j > -1) && (y-1 > -1) && (x-1+j < 10)) pole_ai[x-1+j][y-1]=4;  // задание на поле точек, находящихся выше корабля, на которые нельзя ставить корабли
            if ((x-1+j > -1) && (y+4 < 10) && (x-1+j < 10)) pole_ai[x-1+j][y+4]=4;  // задание на поле точек, находящихся ниже корабля, на которые нельзя ставить корабли
        }
    }
    else {
        if (x > 6)
            x = rand() % 7; // корабль стоит горизонтально
        for (i=0;i<4;i++) {
            ship4_ai[0][i]=x+i;  // задание точек корабля в массиве корабля на оси х
            ship4_ai[1][i]=y;  // задание точек корабля в массиве корабля на оси у
            pole_ai[ship4_ai[0][i]][ship4_ai[1][i]]=1; // задание точек корабля на поле
            if (ship4_ai[1][i]-1 > -1) pole_ai[ship4_ai[0][i]][ship4_ai[1][i]-1]=4; // задание на поле точек, находящихся выше корабля, на которые нельзя ставить корабли
            if (ship4_ai[1][i]+1 < 10) pole_ai[ship4_ai[0][i]][ship4_ai[1][i]+1]=4; // задание на поле точек, находящихся ниже корабля, на которые нельзя ставить корабли
        }
        for (j=0;j<3;j++) {
            if ((y-1+j > -1) && (x-1 > -1) && (y-1+j < 10)) pole_ai[x-1][y-1+j]=4;  // задание на поле точек, находящихся слева от корабля, на которые нельзя ставить корабли
            if ((y-1+j > -1) && (x+4 < 10) && (y-1+j < 10)) pole_ai[x+4][y-1+j]=4;  // задание на поле точек, находящихся справа от корабля, на которые нельзя ставить корабли
        }
    }






}
void point (){ //задание кораблей игрока
    int i;
    int j;
    if (ship4[0][0]>ship4[0][3]) {  //задание и упорядочивание точек 4-ёх плубника
        ship4[0][0]=ship4[0][0]+ship4[0][3];
        ship4[0][3]=ship4[0][0]-ship4[0][3];
        ship4[0][0]=ship4[0][0]-ship4[0][3]; //x0=min(x0,x3) x3=max(x0,x3)
        ship4[0][1]= ship4[0][0]+1; //x1=x0+1
        ship4[0][2]= ship4[0][0]+2; //x2=x0+2
        ship4[1][1] = ship4[1][0]; //y1=y0
        ship4[1][2] = ship4[1][0]; //y2=y0
    }
    else {
        if (ship4[1][0] > ship4[1][3]) {
            ship4[1][0] = ship4[1][0] + ship4[1][3];
            ship4[1][3] = ship4[1][0] - ship4[1][3];
            ship4[1][0] = ship4[1][0] - ship4[1][3]; //y0=min(y0,y3) y3=max(y0,y3)
            ship4[1][1]=ship4[1][0]+1; //y1=y0+1
            ship4[1][2]=ship4[1][0]+2; //y2=y0+2
            ship4[0][1]=ship4[0][0]; //x1=x0
            ship4[0][2]=ship4[0][0]; //x2=x0

        }
    }
    for (j=0;j<4;j++)
        pole_player[ship4[0][j]][ship4[1][j]]=1; //задание и упорядочивание точек 4-ёх палубника на поле игрока
    for (i=0;i<2;i++) {
        if (ship3[0][0][i]>ship3[0][2][i]) { //задание точек 3-ёх плубника
            ship3[0][0][i] = ship3[0][0][i] + ship3[0][2][i];
            ship3[0][2][i] = ship3[0][0][i] - ship3[0][2][i];
            ship3[0][0][i] = ship3[0][0][i] - ship3[0][2][i]; //x0=min(x0,x2) x3=max(x0,x2)
            ship3[0][1][i] = ship3[0][0][i]+1; //x1=x0+1
            ship3[1][1][i] = ship3[1][0][i]; //y1=y0
        }
        else if (ship3[1][0][i]>ship3[1][2][i]) {
            ship3[1][0][i] = ship3[1][0][i] + ship3[1][2][i];
            ship3[1][2][i] = ship3[1][0][i] - ship3[1][2][i];
            ship3[1][0][i] = ship3[1][0][i] - ship3[1][2][i]; //y0=min(y0,y3) y3=max(y0,y3)
            ship3[1][1][i] = ship3[1][0][i]+1; //y1=y0+1
            ship3[0][1][i] = ship3[0][0][i]; //x1=x0

        }
        for (j=0;j<3;j++)
            pole_player[ship3[0][j][i]][ship3[1][j][i]]=1; //задание и упорядочивание точек 3-ёх палубника на поле игрока
    }
    for (i=0;i<3;i++) {
        if (ship2[0][0][i] > ship2[0][1][i]) {  //упорядочивание точек 2-yх плубника
            ship2[0][0][i] = ship2[0][0][i] + ship2[0][1][i];
            ship2[0][1][i] = ship2[0][0][i] - ship2[0][1][i];
            ship2[0][0][i] = ship2[0][0][i] - ship2[0][1][i]; //x0=min(x0,x1) x3=max(x0,x1)
        }
        else if (ship2[1][0][i]>ship2[1][1][i]) {
            ship2[1][0][i] = ship2[1][0][i] + ship2[1][1][i];
            ship2[1][1][i] = ship2[1][0][i] - ship2[1][1][i];
            ship2[1][0][i] = ship2[1][0][i] - ship2[1][1][i]; //y0=min(y0,y1) y3=max(y0,y1)
        }
        for(j=0;j<2;j++)
            pole_player[ship2[0][j][i]][ship2[1][j][i]]=1;
    }
    for (i=0;i<4;i++)
        pole_player[ship1[0][i]][ship1[0][i]]=1;
    }
void player() { // считывает или определяет выстрел
    char x;
    int y;
    if (xod_of_player==1){
        scanf("%c%i",&x,&y); //A=65 a=97
    }
    else {
        srand ( time(NULL) );
        x=rand()%10;
        srand ( time(NULL) );
        y=rand()%10;
    }

}
int main() {
    int i,j;
    for (i=0;i<100;i++) // обнуление клеток полей
        for (j=0;j<100;j++) {
            pole_player[i][j] = 0;
            pole_ai[i][j] = 0;
        }
    //printf();
    scanf("%i%i%i%i",&ship4[0][0],&ship4[1][0],&ship4[0][3],&ship4[1][3]); // координаты начала и конца
    //printf();
    scanf("%i%i%i%i%i%i%i%i",&ship3[0][0][0],&ship3[1][0][0],&ship3[0][2][0],&ship3[1][2][0],&ship3[0][0][1],&ship3[1][0][1],&ship3[0][2][1],&ship3[1][2][1]);  // координаты начала и конца
    //printf();
    scanf("%i%i%i%i%i%i%i%i%i%i%i%i",&ship2[0][0][0],&ship2[1][0][0],&ship2[0][1][0],&ship2[1][1][0],&ship2[0][0][1],&ship2[1][0][1],&ship2[0][1][1],&ship2[1][1][1],&ship2[0][0][2],&ship2[1][0][2],&ship2[0][1][2],&ship2[1][1][2]);  // координаты начала и конца
    //printf();
    scanf("%i%i%i%i%i%i%i%i",&ship4[0][0],&ship4[1][0],&ship4[0][1],&ship4[1][1],&ship4[0][2],&ship4[1][2],&ship4[0][3],&ship4[1][3]);  // координаты начала и конца
    point();
    srand ( time(NULL) );
    ship_ai();
    if (rand()%2==1) xod_of_player=1; // выбирается, кто ходит первым
    else xod_of_player=0;
    player();
    return 0;
}//srand ( time(NULL) ); rand()%10